# Gas 优化

## 减少 SSTORE

打包

The reason is that each state variable corresponds to a certain storage slot, and EVM uses 32-byte storage slots (every storage slot is exactly 32 bytes). When you read a state variable value, it’s get read from the storage slot this variable is linked to. Every SLOAD call reads 32 bytes at a time, and every SSTORE call writes 32 bytes at a time. Since these are expensive operations, we’d really want to reduce the number of storage reads and writes. And this is where proper laying out of state variables might help.

```solidity filename="UniswapV2Pair.sol"

uint112 private reserve0;
uint112 private reserve1;
uint32 private blockTimestampLast;

```

## 减少 SLOAD

案例

Uniswap UniswapV2Pair

```solidity filename="UniswapV2Pair.sol"

    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint amount0, uint amount1) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        address _token0 = token0;                                // gas savings
        address _token1 = token1;                                // gas savings
        uint balance0 = IERC20(_token0).balanceOf(address(this));
        uint balance1 = IERC20(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }
```

## Assembly
